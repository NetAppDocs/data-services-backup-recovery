---
sidebar: sidebar
permalink: br-use-back-up-now-kubernetes-applications-cr.html
keywords: backing up, restoring, back up, backup, restore, cloud volumes ontap, aws, azure, s3, blob, google cloud, storagegrid, back up volumes, cloud backup, restore volumes, cost, on-premises ontap, onprem, applications, virtual machines, backup and recovery, snapcenter
summary: NetApp Backup and Recovery enables you to manage your workload host information, database information, and instances information. You can view, edit, and delete protection settings for your inventory.  
---

= Back up Kubernetes applications now using custom resources
:hardbreaks:
:nofooter:
:icons: font
:linkattrs:
:imagesdir: ./media/

[.lead]
NetApp Backup and Recovery enables you to easily discover your Kubernetes clusters, without generating and uploading kubeconfig files. You can connect Kubernetes clusters and install the required software using simple commands copied from the NetApp Console user interface.

== Back up a Kubernetes application now using custom resources
Manually create a backup of a Kubernetes application to establish a baseline for future backups and snapshots, or to ensure the most recent data is protected.

NOTE: Cluster-scoped resources are included in a backup, snapshot, or clone if they are explicitly referenced in the application definition or if they have references to any of the application namespaces.

include::../_include/backup-include-sessiontoken-note.adoc[]


=== Create a local snapshot using a custom resource
To create a snapshot of your Kubernetes application and store it locally, use the Snapshot custom resource with specific attributes.

.Steps
. Create the custom resource (CR) file and name it `local-snapshot-cr.yaml`. 
. In the file you created, configure the following attributes:
* *metadata.name*: (_Required_) The name of this custom resource; choose a unique and sensible name for your environment.
* *spec.applicationRef*: The Kubernetes name of the application to snapshot.
* *spec.appVaultRef*: (_Required_) The name of the AppVault where the snapshot contents (metadata) should be stored.
* *spec.reclaimPolicy*: (_Optional_) Defines what happens to the AppArchive of a snapshot when the snapshot CR is deleted. This means that even when set to `Retain`, the snapshot will be deleted. Valid options:
** `Retain` (default)
** `Delete`
+
[source,yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: Snapshot
metadata:
  namespace: my-app-namespace
  name: my-cr-name
spec: 
  applicationRef: my-application
  appVaultRef: appvault-name
  reclaimPolicy: Retain
----
+
. After you populate the `local-snapshot-cr.yaml` file with the correct values, apply the CR:
+
[source,console]
----
kubectl apply -f local-snapshot-cr.yaml
----

=== Back up an application to an object store using a custom resource
Create a Backup CR with specific attributes to back up your application to an object store.

.Steps
. Create the custom resource (CR) file and name it `object-store-backup-cr.yaml`. 
. In the file you created, configure the following attributes:
* *metadata.name*: (_Required_) The name of this custom resource; choose a unique and sensible name for your environment.
* *spec.applicationRef*: (_Required_) The Kubernetes name of the application to back up.
* *spec.appVaultRef*: (_Required_) If you use the same bucket to store the snapshot and backup, this is the name of the AppVault where the backup contents should be stored.
* *spec.appVaultTargetsRef*: (_Required_) If you use different buckets to store the snapshot and backup, this is the name of the AppVault where the backup contents should be stored.
* *spec.dataMover*: (_Optional_) A string indicating which backup tool to use for the backup operation. The value is case sensitive and must be `CBS`.
* *spec.reclaimPolicy*: (_Optional_) Defines what happens to a backup when released from its claim. Possible values:
** `Delete`
** `Retain` (default)
//* *spec.snapshotRef*: (_Optional_) Name of the snapshot to use as the source of the backup. If not provided, a temporary snapshot will be created and backed up.
* *spec.cleanupSnapshot*: (_Required_) Ensures that the temporary snapshot created by the Backup CR is not deleted after the backup operation completes. Recommended value: `false`.
+
Example YAML when using the same bucket to store the snapshot and backup:
+
[source,yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: Backup
metadata:
  namespace: my-app-namespace
  name: my-cr-name
spec: 
  applicationRef: my-application
  appVaultRef: appvault-name
  dataMover: CBS
  reclaimPolicy: Retain
  cleanupSnapshot: false
----
+
Example YAML when using different buckets to store the snapshot and backup:
+
[source,yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: Backup
metadata:
  namespace: my-app-namespace
  name: my-cr-name
spec: 
  applicationRef: my-application
  appVaultTargetsRef: appvault-targets-name
  dataMover: CBS
  reclaimPolicy: Retain
  cleanupSnapshot: false
----
+
. After you populate the `object-store-backup-cr.yaml` file with the correct values, apply the CR:
+
[source,console]
----
kubectl apply -f object-store-backup-cr.yaml
----

=== Create a 3-2-1 fanout backup using a custom resource
Backing up using a 3-2-1 fanout architecture copies a backup to secondary storage as well as to an object store. To create a 3-2-1 fanout backup, create a Backup CR with specific attributes.

.Steps
. Create the custom resource (CR) file and name it `3-2-1-fanout-backup-cr.yaml`. 
. In the file you created, configure the following attributes:
* *metadata.name*: (_Required_) The name of this custom resource; choose a unique and sensible name for your environment.
* *spec.applicationRef*: (_Required_) The Kubernetes name of the application to back up.
* *spec.appVaultTargetsRef*: (_Required_) The name of the AppVault where the backup contents should be stored.
* *spec.dataMover*: (_Optional_) A string indicating which backup tool to use for the backup operation. The value is case sensitive and must be `CBS`.
* *spec.reclaimPolicy*: (_Optional_) Defines what happens to a backup when released from its claim. Possible values:
** `Delete`
** `Retain` (default)
//* *spec.snapshotRef*: (_Optional_): Name of the snapshot to use as the source of the backup. If not provided, a temporary snapshot will be created and backed up.
* *spec.cleanupSnapshot*: (_Required_) Ensures that the temporary snapshot created by the Backup CR is not deleted after the backup operation completes. Recommended value: `false`.
* *spec.replicateSnapshot*: (_Required_) Instructs Backup and Recovery to replicate the snapshot to secondary storage. Required value: `true`.
* *spec.replicateSnapshotReclaimPolicy*: (_Optional_) Defines what happens to a snapshot when the original is deleted. Possible values:
** `Delete`
** `Retain` (default)
+
Example YAML:
+
[source,yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: Backup
metadata:
  namespace: my-app-namespace
  name: my-cr-name
spec: 
  applicationRef: my-application
  appVaultTargetsRef: appvault-targets-name
  dataMover: CBS
  reclaimPolicy: Retain
  cleanupSnapshot: false
  replicateSnapshot: true
  replicateSnapshotReclaimPolicy: Retain
----
+
. After you populate the `3-2-1-fanout-backup-cr.yaml` file with the correct values, apply the CR:
+
[source,console]
----
kubectl apply -f 3-2-1-fanout-backup-cr.yaml
----

////
==== Create a ReplicateSnapshot custom resource
Create a ReplicateSnapshot custom resource to copy the local snapshot to secondary storage, which completes the 3-2-1 backup architecture.

.Steps
. Create the custom resource (CR) file and name it `3-2-1-fanout-replicateSnapshot-cr.yaml`. 
. In the file you created, configure the following attributes:
* *metadata.name*: (_Required_) The name of this custom resource; choose a unique and sensible name for your environment.
* *spec.applicationRef*: (_Required_) The Kubernetes name of the application whose snapshot will be replicated to secondary storage.
* *spec.reclaimPolicy*: (_Optional_) Defines what happens to the replicated snapshot when the original is deleted. Possible values:
** `Delete`
** `Retain` (default)
* *spec.snapshotRef*: (_Required_): The name of the snapshot to copy to secondary storage.
+
Example YAML:
+
[source,yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: ReplicateSnapshot
metadata:
  namespace: my-app-namespace
  name: my-cr-name
spec:
  applicationRef: my-application 
  reclaimPolicy: Retain 
  snapshotRef: snapshot-name
----
+
. After you populate the `3-2-1-fanout-replicateSnapshot-cr.yaml` file with the correct values, apply the CR:
+
[source,console]
----
kubectl apply -f 3-2-1-fanout-replicateSnapshot-cr.yaml
----

////

== Supported backup annotations
The following table describes the annotations you can use when creating a backup CR.

[cols="2,1,3,1",options="header"]
|===
|Annotation
|Type
|Description
|Default value
|protect.trident.netapp.io/full-backup
|string
|Specifies whether a backup should be non-incremental. Set to `true` to create a non-incremental backup. It is best practice to perform a full backup periodically and then perform incremental backups in between full backups to minimize the risk associated with restores.
|"false"
|protect.trident.netapp.io/snapshot-completion-timeout
|string
|The maximum time allowed for the overall snapshot operation to complete.
|"60m"
|protect.trident.netapp.io/volume-snapshots-ready-to-use-timeout
|string
|The maximum time allowed for volume snapshots to reach the ready-to-use state.
|"30m"
|protect.trident.netapp.io/volume-snapshots-created-timeout
|string
|The maximum time allowed for volume snapshots to be created.
|"5m"
|protect.trident.netapp.io/pvc-bind-timeout-sec
|string
|Maximum time (in seconds) to wait for any newly created PersistentVolumeClaims (PVCs) to reach the `Bound` phase before the operations fails.
|"1200" (20 minutes)
|===

== View collected resources for a backup using a custom resource
Use a ResourceViewer CR to see what resources were collected as part of a snapshot or backup.

.Steps
. Create the view resources CR file:
.. Create the custom resource (CR) file and name it (for example, `view-resources.yaml`).
.. Configure the following attributes:
+
* *metadata.name*: (_Required_) The name of the application custom resource. Note the name you choose because other CR files needed for protection operations refer to this value.
* *metadata.ui-correclation-id*: (_Required_) 
* *spec.includedNamespaces*: (_Required_) Use namespace and label selector to specify the namespaces and resources that the application uses. The application namespace must be part of this list. The label selector is optional and can be used to filter resources within each specified namespace.
* *spec.includedClusterScopedResources*: (_Optional_) Use this attribute to specify cluster-scoped resources to be included in the application definition. This attribute allows you to select these resources based on their group, version, kind, and labels.
+
** *groupVersionKind*: (_Required_) Specifies the API group, version, and kind of the cluster-scoped resource.
+
** *labelSelector*: (_Optional_)  Filters the cluster-scoped resources based on their labels.
+
Example YAML:
+
[source, yaml]
----
apiVersion: protect.trident.netapp.io/v1
kind: ResourceViewer
metadata:
  name: name
  namespace: <namespace of application, or an includedNamespace>
  annotations:
	ui-correlation-id: <correlationID from Trident Protect>
  ownerReferences: # optional based on creator
  - apiVersion: protect.trident.netapp.io/v1
	blockOwnerDeletion: true
	controller: true
	kind: Application
	name: ns1-app
	uid: c1a6d240-7a97-42cd-80c3-b003c09aea73
spec:
  applicationRef: # optional, based on the creator of this CR
	- namespace: ns1
	  name: ns1-app
  definition:
    includedNamespaces:
    - namespace: ns1
      labelSelector: 
        matchLabels:
          color: blue
      matchExpressions:
      - key: color
        operator: notin
        values:
        - orange
    includedClusterScopedResources:
    - groupVersionKind:
        group: ""
        kind: Node
        version: v1
      labelSelector: {}
status:
  totalParts: 5 # calculated number of chunks
  currentPart: 1 # which chunk the below data pertains to
  data: '{"apps/v1/ControllerRevision":["mysql/mysql-5dbcf9cf88"],"apps/v1/StatefulSet":["mysql/mysql"],"networking.k8s.io/v1/NetworkPolicy":["mysql/mysql"],"policy/v1/PodDisruptionBudget":["mysql/mysql"],"rbac.authorization.k8s.io/v1/ClusterRole":["/system:basic-user","/system:discovery","/system:public-info-viewer","/system:service-account-issuer-discovery"],"rbac.authorization.k8s.io/v1/ClusterRoleBinding":'
----

+
. After you populate the `view-resources-cr.yaml` file with the correct values, apply the CR:
+
[source,console]
----
kubectl apply -f view-resources-cr.yaml
----


